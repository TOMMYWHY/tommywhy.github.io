{"meta":{"title":"Tommywhy's blog","subtitle":"Full stack developer。","description":null,"author":"Tommy Jiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-26T08:14:24.000Z","updated":"2019-06-16T11:50:16.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Life was like a box of chocolates. You never know what you’re gonna get. I am a wild web developer… Loving Laravel, Learning Magento2. Admiring Java, Using PHP. Work Experience Samsung Customer Service Plaza (Auckland) Repair Tech ltd (Hamilton) Mobile Muster (Auckland) 3A IT SOLUTIONS LTD. (Auckland) Links GitHub：https://github.com/ Linkedin: https://www.linkedin.com/in/tommy-jiang-a38529129/ Website：http://tommywhy.com/ Portfoliohttp://repairtech.co.nz/http://applerepair.co.nz/https://mobilemuster.co.nz/http://movie.tommywhy.cf/http://collinsongt.co.nz/en/http://royaldeer.co.nz/http://msloan.co.nz/http://www.digital-image.co.nz/http://www.strongmotor.co.nz/http://www.waiukumotel.co.nz/wm/"},{"title":"Categories","date":"2019-05-26T07:51:18.000Z","updated":"2019-05-26T08:50:57.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-26T07:55:27.000Z","updated":"2019-05-26T07:56:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS数组","slug":"JS数组","date":"2019-08-23T11:24:45.000Z","updated":"2019-09-17T11:32:36.000Z","comments":true,"path":"2019/08/23/JS数组/","link":"","permalink":"http://yoursite.com/2019/08/23/JS数组/","excerpt":"","text":"最近在学习《数据结构与算法》，数据结构中数组的重要性不言而喻。 由于 js 随意的动态性，总结一下数组的用法。 Arrayarray 定义 通过 new Array 创建数组时， 如果是一个参数且必须是个正整数，就是在定义长度。若是多个参数，则是赋值。1var arr = new Array(5); //定义数组长度 ps: 在我看来，这是最不负责任的数组。 Array如果通过索引赋值时，索引超过了范围，同样会引起ƒ大小的变化。大多数其他编程语言不允许直接改变数组的大小(如：java)，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 同理，修改 arr.length 的值，一样改变数组长度。 改变原数组的方法 [push, pop, shift, unshift, sort, reverse, splice] push 与 pop与 数据 栈 stack 的 push、pop 方法概念相同，先进后出。由于 length 随意更改，可得 push 的实现原理： 12345Array.prototype.myPush = function () &#123; for (let i = 0; i &lt; arguments.length; i++) &#123; this[this.length] = arguments[i]; &#125; &#125; unshift 和 shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 1234567Array.prototype.myUnShift = function () &#123; var newArr = [] for (let i = 0; i &lt; arguments.length; i++) &#123; newArr[i] = arguments[i]; &#125; return newArr.concat(this); &#125; 要注意的是 arguments 是个类数组对象，无法直接使用 concat 方法。 splice 切片 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：splice(开始切，截取长度，切口处加入新元素)12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：但是 js 中 sort 与其他语言差距较大(如：java)，排序是ascII 码 排序。123456789101112var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C']arr1 = [1,20,10,3];arr1.sort()arr1;// [1, 10, 20, 3]// 比较 参数，return 正数 交换位置(即：a&gt;b)，return 负数 位置不变。arr1.sort((a,b)=&gt;&#123; return a-b; &#125;) //[1, 3, 10, 20] sort 传入回调函数，可以实现乱序。123arr1.sort(() =&gt; &#123; return Math.random() - 0.5; &#125;) 不改变原数组的方法 [ concat, join, split, toString, slice] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] //原数组 不变 注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] 由于数组是典型的引用类型，数组赋值等操作时需要 concat。1arr.push([].concat(temp)) slice 截取slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：前开后闭123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false //深拷贝 第三个参数是 删除位置 将替换的内容1arr.splice(0, 2, temp); //将 0 1替换 temp joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。不传参数将自动以 ‘,’ 分隔。 注意 字符串中 split() 与 join 是可逆操作。 every 与 forEach","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS中的this","slug":"JS中的this","date":"2019-08-05T10:05:39.000Z","updated":"2019-08-23T11:22:57.000Z","comments":true,"path":"2019/08/05/JS中的this/","link":"","permalink":"http://yoursite.com/2019/08/05/JS中的this/","excerpt":"","text":"this 这个东西一直很酷扰我。昨天更是让我 debug 了一夜。。。 于是决心记录一下 this 原理正规调用函数方法是用 call(), 其中第一个参数就是 this， 即调用函数的对象。1fn().call(undefined,args[,,,]) 如果 this 是 undefined， 在 DOM 中非严格模式下，this 就指向了 window call ， apply ， bindcall() 执行的时候将剩余参数一次传入；apply() 则将剩余参数作为数组传入。bind() 只有一个参数， 那就是 this。 除了绑定 this 别无他用。 特例绑定点击时间中的 this，指的是被触发的元素本身。 1234567window.addEventListener('scroll', function(e) &#123; if (window.scrollY &gt; 0) &#123; this.active() // this 是被监听 元素 &#125; else &#123; this.deactive() &#125; &#125;) 箭头函数()=&gt;{} 中不绑定 this 的， 换言之，箭头函数中没有 this，如果出现 this， 向上查找。内外 this 不变。 12345678910bindEvents: function () &#123; let view = this.view window.addEventListener('scroll', (e)=&gt; &#123; if (window.scrollY &gt; 0) &#123; this.active()// 上面 view 的 this 是同一个 &#125; else &#123; this.deactive() &#125; &#125;)&#125;, Tip使用 VS code 可以轻松搞定 this。 但是有的时候不是很准确，但是大致可以确定 this 的指向。","categories":[{"name":"front end","slug":"front-end","permalink":"http://yoursite.com/categories/front-end/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"HTML & CSS","slug":"html","date":"2019-06-23T05:22:10.000Z","updated":"2019-08-16T08:01:49.000Z","comments":true,"path":"2019/06/23/html/","link":"","permalink":"http://yoursite.com/2019/06/23/html/","excerpt":"","text":"HTML5 与 CSS3 自认为基础已经娴熟，但还是有很多 tricky 点不了解。特开贴记录。 HTML5dl 标签 表格标签，从未使用过。类似于 table，但还有所不同。 仅使用 键值对 的表格。 123456789&lt;dl&gt;&lt;dt&gt;Age&lt;/dt&gt;&lt;dd&gt;29&lt;/dd&gt;&lt;dt&gt;Location&lt;/dt&gt;&lt;dd&gt;Auckland&lt;/dd&gt;&lt;dt&gt;Email&lt;/dt&gt;&lt;dd&gt;tommywhy1989@gmail.com&lt;/dd&gt;&lt;/dl&gt; 标签高度 尽量把确定的宽高写在标签属性上，以减少元素重排浪费内存。 小优化。 属性 属性一定要看好，不要有空格，不然js取到的值是 undefined CSS3border 浮动时可以将 border 算入百分比中。123&#123;box-sizing: border-box; width:50%;float:left;&#125; inline-block 当使用inline-block后，会在底部多出几像素的空白。 两句配合可应付处女座级别的客户需求。12&#123;display: inline-block;vertical-align: top;&#125; css 选择器 多类选择器：无空格。 即 section 的同时是 .skills1section.skills &gt; h2&#123;&#125; 后代选择器： 有空格。 即 userCard 下面找 text 找 summary1.userCard .text .summary h1 子类中个别偶数选择。1section.skills &gt; ol &gt; li:nth-child(even)&#123;&#125; 属性选择器,1[data-x]&#123;transform: translateY(0);transition: all .4s;&#125; ps: css只负责动画效果，js 只负责找DOM元素利用 js 控制 .active 的添加与删除实现动画。12.topNavBar nav li.active &gt; a::after ,.topNavBar nav li.highlight &gt; a::after&#123;&#125; css 阴影 实用工具=&gt;阴影生成器https://www.cssmatic.com/box-shadow css 伪类 before after 用的很少。其实做很多，不过容易给他人阅读造成困扰。太极图http://tommywhy.com/effects/yinYang.html 占位做登录验证的时候有个小需求，就是在input 后面输出错误信息。登录框宽度不定的情况下使用伪类占位，验证信息直接填充在 content 中。12345.container .formControl&gt;.error:after &#123; display: inline-block; content: attr(text-content-after); width: 10em; &#125; html 的 text-content-after 可以获取到 伪类的 content 值1&lt;span class=\"error\" text-content-after='''&gt;&lt;/span&gt; 再用 js 将错误信息 填充到 text-content-after 中。1$form.find('[name = \"email\"]').siblings('.error').attr(\"text-content-after\", 'email error~！') 这样就实现了伪类提示错误信息。避免html结构复杂化。 真香~！","categories":[{"name":"front end","slug":"front-end","permalink":"http://yoursite.com/categories/front-end/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://yoursite.com/tags/HTML-CSS/"}]},{"title":"JS遗珠","slug":"JS遗珠","date":"2019-06-08T00:03:25.000Z","updated":"2019-08-23T13:08:59.000Z","comments":true,"path":"2019/06/08/JS遗珠/","link":"","permalink":"http://yoursite.com/2019/06/08/JS遗珠/","excerpt":"","text":"对于Javascript 的学习从未停止过，奈何其水深无法想象。JS基础回顾，作为前端部分开篇内容再好不过了。 其中包括了 聊雪峰、阮一峰、方应航等大神博文，还有j《avascript 高级程序设计》 一书的内容。 夯实基础，开卷有益。 basicscript 标签又六个属性。不要用延迟脚本。 阻断式语言：解释器求值完毕之前，网页不会加载。解释器预处理，再执行。 手机端：js内部文件可以起到性能优化。 唯一能判断NaN的方法是通过isNaN()函数： 1isNaN(NaN); // true String 字符串js 中 string 属于基本数据类型 (不同于 java 中的 String) ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 注： 模板字符串中回车换行也算字符长度。 toString三种方法 ToString， 其中 null 与 undefined 进行 ToString 汇报错。12341+''String(1)(1).toString()\"1\" string 相关操作方法 trim() 去掉调用字符串的前后空格。 substring()返回指定索引区间的子串： 123var s = &apos;hello, world&apos;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; concat() 拼接两个字符串并返回新的字符串。同 Array。 4.slice() 裁切，同 Array 。 repalce() 替换字符串中一个字符。 Boolean 布尔每次看到 boolean 内心都不有的为布尔惋惜。俗话说：『老婆取得好，能够活到老啦』 ToBoolean两种方式 ToBoolean:123Boolean('2')!!\"2\"true 五个 Falsy 值 ：0，NaN，null, undefined, &#39;&#39; Number 数字ToNumber五种方法进行 ToNumber 操作：12345Number(\"1\")parseInt('1',10) // 第二个参数表示10进制parseFloat('1.2')\"1\" - 0+ \"1\" // 取正 Object 对象ToObject访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用&#39;&#39;括起来： 1234var xiaohong = &#123; name: &apos;小红&apos;, &apos;middle-school&apos;: &apos;No.1 Middle School&apos;&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用&#39;&#39;括起来。访问这个属性也无法使用.操作符，必须用[&#39;xxx&#39;]来访问： 123xiaohong[&apos;middle-school&apos;]; // &apos;No.1 Middle School&apos;xiaohong[&apos;name&apos;]; // &apos;小红&apos;xiaohong.name; // &apos;小红&apos; 也可以用xiaohong[&#39;name&#39;]来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.hasOwnProperty(&apos;name&apos;); // truexiaoming.hasOwnProperty(&apos;toString&apos;); // false for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos;&#125;;for (var key in o) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 12345678910var o = &#123; name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos;&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos; &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];for (var i in a) &#123; console.log(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos; console.log(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 请注意，for ... in对Array的循环得到的是String而不是Number。 set map……..遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。注意区别 for in。 for in 不完善，仅限于对象输出。然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：1234567var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + &apos;, index = &apos; + index);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.forEach(function (element) &#123; console.log(element);&#125;); functionarguments最常用于判断传入参数的个数。你可能会看到这样的写法： 12345678910// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125; ES6标准引入了rest参数，用于接收未定义的多余参数： 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log(&apos;a = &apos; + a); console.log(&apos;b = &apos; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] 作用域自定义全局作用域：减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 letlet 的作用：由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 12345678&apos;use strict&apos;;function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 12345678910&apos;use strict&apos;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 解构赋值123~~~var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];~~~ 从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性： 12345678910111213141516171819var person = &#123; name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;, address: &#123; city: &apos;Beijing&apos;, street: &apos;No.1 Road&apos;, zipcode: &apos;100001&apos; &#125;&#125;;var &#123;name, address: &#123;city, zip&#125;&#125; = person;name; // &apos;小明&apos;city; // &apos;Beijing&apos;zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取： 123456789101112131415var person = &#123; name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;&#125;;// 把passport属性赋值给变量id:let &#123;name, passport:id,single=true&#125; = person;name; // &apos;小明&apos;single; // trueid; // &apos;G-12345678&apos;// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： 1(&#123;x, y&#125; = &#123; name: &apos;小明&apos;, x: 100, y: 200&#125;); 快速获取当前页面的域名和路径： 1var &#123;hostname:domain, pathname:path&#125; = location; // 重命名爲domain 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： 123function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hour + &apos;:&apos; + minute + &apos;:&apos; + second);&#125; 它的方便之处在于传入的对象只需要year、month和day这三个属性： 12buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);// Sun Jan 01 2017 00:00:00 GMT+0800 (CST) 也可以传入hour、minute和second属性： 12buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);// Sun Jan 01 2017 20:15:00 GMT+0800 (CST) this用一个that变量首先捕获this： 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。12345678910111213141516&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 arr.map() arr.reduce()map()、reduce、filter()、sort()、every()、find()、findIndex()、forEach()、 、 closure返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 obj总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 number对象调用toString()报SyntaxError： 1123.toString(); // SyntaxError 遇到这种情况，要特殊处理一下： 12123..toString(); // &apos;123&apos;, 注意是两个点！(123).toString(); // &apos;123&apos; JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 regExp无法识别连续的空格，用正则表达式试试： 1&apos;a b c&apos;.split(/\\s+/); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] jason统一解析，JSON的字符串规定必须用双引号&quot;&quot;，Object的键也必须用双引号&quot;&quot;对象序列化成JSON格式的字符串： 12345678910111213&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, age: 14, gender: true, height: 1.65, grade: null, &apos;middle-school&apos;: &apos;\\&quot;W3C\\&quot; Middle School&apos;, skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;]&#125;;var s = JSON.stringify(xiaoming);console.log(s); 要输出得好看一些，可以加上参数，按缩进输出： 1JSON.stringify(xiaoming, null, &apos; &apos;); 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array： 1JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos; &apos;); 结果： 123456789&#123; &quot;name&quot;: &quot;小明&quot;, &quot;skills&quot;: [ &quot;JavaScript&quot;, &quot;Java&quot;, &quot;Python&quot;, &quot;Lisp&quot; ]&#125; 反序列化拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象： 1234JSON.parse(&apos;[1,2,3,true]&apos;); // [1, 2, 3, true]JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;); // Object &#123;name: &apos;小明&apos;, age: 14&#125;JSON.parse(&apos;true&apos;); // trueJSON.parse(&apos;123.45&apos;); // 123.45 JSON.parse()还可以接收一个函数，用来转换解析出的属性： 12345678&apos;use strict&apos;;var obj = JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;, function (key, value) &#123; if (key === &apos;name&apos;) &#123; return value + &apos;同学&apos;; &#125; return value;&#125;);console.log(JSON.stringify(obj)); // &#123;name: &apos;小明同学&apos;, age: 14&#125; DOMjs 最重要的任务是找到 DOM 上的 element，然后负责添加 css效果类。 选择器集合选择器1document.querySelectorAll('\\[data-x\\]') 元素选择器1document.querySelector('a\\[href=\"#'+ id +'\"\\]').parentNode","categories":[{"name":"front end","slug":"front-end","permalink":"http://yoursite.com/categories/front-end/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"sql","slug":"sql","date":"2019-06-07T23:53:35.000Z","updated":"2019-06-09T02:17:45.000Z","comments":true,"path":"2019/06/08/sql/","link":"","permalink":"http://yoursite.com/2019/06/08/sql/","excerpt":"","text":"作为一名程序员，最终要的是数据。 DB 分类的开篇总结一些常用的命令，为以后漫长的数据之旅打下基础。 mysql cmd服务器上常用mysql命令 123mysql -u root -pmysql -h 10.0.1.99 -u root -p // -h 指定IP或域名 sql statement通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。 查询 排序。列有相同的数据，要进一步排序。1SELECT id, name, gender, score FROM students ORDER BY score DESC，gender; 分页: LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。1234SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。COUNT(*)和COUNT(id)实际上是一样的效果。1SELECT COUNT(*) num FROM students; ROUP BY子句指定了按class_id分组1SELECT COUNT(*) num FROM students GROUP BY class_id; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。123456789SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &apos;M&apos; AND c.id = 1; inner join 会丢失两表中null 值得数据，这是可以使用FULL OUTER JOIN1234SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id; 要特别小心的是，UPDATE语句可以没有WHERE条件，整个表的所有记录都会被更新。1234~~~UPDATE students SET score=60;~~~","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"Git","slug":"Git","date":"2019-05-27T08:22:46.000Z","updated":"2019-06-17T10:07:03.000Z","comments":true,"path":"2019/05/27/Git/","link":"","permalink":"http://yoursite.com/2019/05/27/Git/","excerpt":"","text":"开篇想了很久才决定要写什么，作为一名 Web 开发人员，第一必备的技能应该就是 git 了。没什么好说的，记录git一些常用命令，以备查阅。 git 命令 cmd最常用的命令 12345git addgit commitgit status -sb // 参数 sb 很有用~！git diffgit push git 的状态git init 123456$ git init //这是一个空的仓库Initialized empty Git repository in $ git status -sb // 此时状态为 未跟踪，此时创建文件后为 红色 M On branch masterInitial commitUntracked files:xxxx git add123456789修改文件后$ git status -sb // 修改文件在工作区，未提交到 stage。 此时为绿色 M On branch masterChanges not staged for commit: $ git add ./* $ git status // 从工作区 add 到 stage 区xxxxChanges to be committed: git commit123$ git commit -m &quot;xxx&quot;// 从 stage 提交到 master git checkout123git checkout --xx //丢弃xx文件工作区修改。.让这个文件回到最近一次git checkout dev //切换分支 分支：123456git branch; // 查看当前分支git branch dev; 创建分支git checkout dev ;切换分支git checkout -b dev; 创建并且换git merge dev; 先处在master 然后合并分支dev到mastergit merge --no-ff -m &quot;merge with no-ff&quot; dev //最好使用这条,禁用Fast forward log1git log --graph --pretty=oneline --abbrev-commit stash 雪藏12// 历史将为编辑好工作区缓存去来git stash git stash list git stash apply git stash drop git stash pop git remote -v1git remote -v //查看远端库 tag // 易于团队版本号查询，目前用不上 解决冲突 1234567891011121314151617git diff // 查看不同git log --pretty=onelinegit reset --hard HEAD^ //退回上一个版本 git reset --hard 1094a //退回固定版本git refloggit checkout --xxx //直接丢弃工作区的修改//当你不但改乱了工作区某个文件的内容，还添加到了stage区时(add)，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。git branch dev; git checkout dev ;git checkout -b dev //创建并切换分支git merge dev; git merge --no-ff -m &quot;merge with no-ff&quot; dev // 合并分支， 在master分支下，合并devgit log --graph --pretty=oneline --abbrev-commitgit stash git stash list git stash apply git stash drop git stash popgit remote -v github 生成本地钥匙和锁1ssh-keygen -t rsa -b 4096 -C \"email.address\" ~/.ssh 中 生成 钥匙：id_rsa 与 锁 id_rsa.pub。 将 锁 id_rsa.pub 上传到github。 尝试连接github，用本地的 钥匙 去开 github 上的锁1ssh -T git@github.com 连接成功后，会将github IP 保存到 known_hosts 中。 至此， 本地与github建立连接。 git 本地配置 1git config XXXX // 看文档吧。一辈子配置不了几次。 完。","categories":[{"name":"效率","slug":"效率","permalink":"http://yoursite.com/categories/效率/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-26T01:45:48.000Z","updated":"2019-05-26T01:45:48.000Z","comments":true,"path":"2019/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}