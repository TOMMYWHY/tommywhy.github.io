<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS数组</title>
      <link href="/2019/08/23/JS%E6%95%B0%E7%BB%84/"/>
      <url>/2019/08/23/JS%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>最近在学习《数据结构与算法》，数据结构中数组的重要性不言而喻。 由于 js 随意的动态性，总结一下数组的用法。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="array-定义"><a href="#array-定义" class="headerlink" title="array 定义"></a>array 定义</h4><ol><li>通过 new Array 创建数组时， 如果是<strong>一个参数</strong>且必须是个正整数，就是在定义长度。若是多个参数，则是赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(5); //定义数组长度</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>ps: 在我看来，这是最不负责任的数组。</p></blockquote><ol start="2"><li>Array如果通过索引<strong>赋值</strong>时，索引超过了范围，同样会引起<code>ƒ</code>大小的变化。<br>大多数其他编程语言不允许直接改变数组的大小(如：java)，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></span><br></pre></td></tr></table></figure></li></ol><p>同理，修改 arr.length 的值，一样改变数组长度。</p><h4 id="改变原数组的方法-push-pop-shift-unshift-sort-reverse-splice"><a href="#改变原数组的方法-push-pop-shift-unshift-sort-reverse-splice" class="headerlink" title="改变原数组的方法 [push, pop, shift, unshift, sort, reverse, splice]"></a>改变原数组的方法 [push, pop, shift, unshift, sort, reverse, splice]</h4><ol><li><p>push 与 pop<br>与 数据 <strong>栈</strong> stack 的 push、pop 方法概念相同，先进后出。<br>由于 length 随意更改，可得 push 的实现原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myPush = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>[<span class="keyword">this</span>.length] = <span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unshift 和 shift<br>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myUnShift = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> newArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">newArr[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr.concat(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>要注意的是 arguments 是个类数组对象，无法直接使用 concat 方法。</p><ol start="3"><li>splice 切片</li></ol><p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：<br><code>splice(开始切，截取长度，切口处加入新元素)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>sort<br><code>sort()</code>可以对当前<code>Array</code>进行排序，它会直接修改当前<code>Array</code>的元素位置，直接调用时，按照默认顺序排序：<br>但是 js 中 sort 与其他语言差距较大(如：java)，排序是ascII 码 排序。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">3</span>];</span><br><span class="line">arr1.sort()</span><br><span class="line">arr1;<span class="comment">// [1, 10, 20, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较 参数，return 正数 交换位置(即：a&gt;b)，return 负数 位置不变。</span></span><br><span class="line">arr1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//[1, 3, 10, 20]</span></span><br></pre></td></tr></table></figure></li></ol><p>sort 传入回调函数，可以实现乱序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1.sort(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="不改变原数组的方法-concat-join-split-toString-slice"><a href="#不改变原数组的方法-concat-join-split-toString-slice" class="headerlink" title="不改变原数组的方法 [ concat, join, split, toString, slice]"></a>不改变原数组的方法 [ concat, join, split, toString, slice]</h4><ol><li>concat<br><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C'] //原数组 不变</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p><p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><ol start="2"><li>slice 截取<br><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：<br>前开后闭<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></span><br></pre></td></tr></table></figure></li></ol><p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></span><br><span class="line">aCopy === arr; <span class="comment">// false //深拷贝</span></span><br></pre></td></tr></table></figure><ol start="3"><li>join<br><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure><p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。<br>不传参数将自动以 ‘,’ 分隔。</p><p><strong>注意</strong>  字符串中 split() 与 join 是可逆操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的this</title>
      <link href="/2019/08/05/JS%E4%B8%AD%E7%9A%84this/"/>
      <url>/2019/08/05/JS%E4%B8%AD%E7%9A%84this/</url>
      
        <content type="html"><![CDATA[<p>this 这个东西一直很酷扰我。昨天更是让我 debug 了一夜。。。 </p><p>于是决心记录一下 <font color="#dd0000">this</font></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>正规调用函数方法是用 call(), 其中第一个参数就是 this， 即调用函数的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn().call(<span class="literal">undefined</span>,args[,,,])</span><br></pre></td></tr></table></figure></p><p>如果 this 是 undefined， 在 DOM 中非严格模式下，this 就指向了 window</p><h3 id="call-，-apply-，-bind"><a href="#call-，-apply-，-bind" class="headerlink" title="call ， apply ， bind"></a>call ， apply ， bind</h3><p>call() 执行的时候将剩余参数一次传入；<br>apply() 则将剩余参数作为数组传入。<br>bind() 只有一个参数， 那就是 this。 除了绑定 this 别无他用。</p><h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>绑定点击时间中的 this，指的是被触发的元素本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.active() <span class="comment">// this 是被监听 元素</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.deactive()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>()=&gt;{} 中不绑定 this 的， 换言之，箭头函数中没有 this，如果出现 this， 向上查找。内外 this 不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bindEvents: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="keyword">this</span>.view </span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, (e)=&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.active()<span class="comment">// 上面 view 的 this 是同一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.deactive()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>使用 VS code 可以轻松搞定 this。 但是有的时候不是很准确，但是大致可以确定 this 的指向。</p>]]></content>
      
      
      <categories>
          
          <category> front end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML &amp; CSS</title>
      <link href="/2019/06/23/html/"/>
      <url>/2019/06/23/html/</url>
      
        <content type="html"><![CDATA[<p>HTML5 与 CSS3 自认为基础已经娴熟，但还是有很多 tricky 点不了解。特开贴记录。</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="dl-标签"><a href="#dl-标签" class="headerlink" title="dl 标签"></a>dl 标签</h3><blockquote><p>表格标签，从未使用过。类似于 table，但还有所不同。 仅使用 键值对 的表格。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Age<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>29<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Location<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Auckland<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>tommywhy1989@gmail.com<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="标签高度"><a href="#标签高度" class="headerlink" title="标签高度"></a>标签高度</h3><blockquote><p>尽量把确定的宽高写在标签属性上，以减少元素重排浪费内存。 小优化。</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>属性一定要看好，不要有空格，不然js取到的值是 undefined</p></blockquote><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><blockquote><p>浮动时可以将 border 算入百分比中。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">box-sizing</span>: border-box; </span><br><span class="line"><span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line"><span class="attribute">float</span>:left;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><blockquote><p>当使用inline-block后，会在底部多出几像素的空白。 两句配合可应付处女座级别的客户需求。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">vertical-align</span>: top;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h3><blockquote><p>多类选择器：无空格。 即 section 的同时是 .skills<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span><span class="selector-class">.skills</span> &gt; <span class="selector-tag">h2</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>后代选择器： 有空格。 即 userCard 下面找 text 找 summary<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.userCard</span> <span class="selector-class">.text</span> <span class="selector-class">.summary</span> <span class="selector-tag">h1</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>子类中个别偶数选择。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span><span class="selector-class">.skills</span> &gt; <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(even)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>属性选择器,<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[data-x]</span>&#123;<span class="attribute">transform</span>: <span class="built_in">translateY</span>(0);<span class="attribute">transition</span>: all .<span class="number">4s</span>;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>ps: css只负责动画效果，js 只负责找DOM元素<br>利用 js 控制 .active 的添加与删除实现动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.topNavBar nav li.active &gt; a::after ,</span><br><span class="line">.topNavBar nav li.highlight &gt; a::after&#123;&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="css-阴影"><a href="#css-阴影" class="headerlink" title="css 阴影"></a>css 阴影</h3><blockquote><p>实用工具=&gt;阴影生成器<br><a href="阴影生成器">https://www.cssmatic.com/box-shadow</a></p></blockquote><h3 id="css-伪类"><a href="#css-伪类" class="headerlink" title="css 伪类"></a>css 伪类</h3><blockquote><p>before after 用的很少。其实做很多，不过容易给他人阅读造成困扰。<br>太极图<br><a href="http://tommywhy.com/effects/yinYang.html" target="_blank" rel="noopener">http://tommywhy.com/effects/yinYang.html</a> </p></blockquote><h4 id="占位"><a href="#占位" class="headerlink" title="占位"></a>占位</h4><p>做登录验证的时候有个小需求，就是在input 后面输出错误信息。<br>登录框宽度不定的情况下使用伪类占位，验证信息直接填充在 content 中。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.formControl</span>&gt;<span class="selector-class">.error</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: inline-block;</span><br><span class="line">            <span class="attribute">content</span>: <span class="built_in">attr</span>(text-content-after);</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>html 的 text-content-after 可以获取到 伪类的 content 值<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"error"</span> <span class="attr">text-content-after</span>=<span class="string">''</span>'&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>再用 js 将错误信息 填充到 text-content-after 中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$form.find(<span class="string">'[name = "email"]'</span>).siblings(<span class="string">'.error'</span>).attr(<span class="string">"text-content-after"</span>, <span class="string">'email error~！'</span>)</span><br></pre></td></tr></table></figure></p><p>这样就实现了伪类提示错误信息。避免html结构复杂化。 真香~！</p>]]></content>
      
      
      <categories>
          
          <category> front end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS遗珠</title>
      <link href="/2019/06/08/JS%E9%81%97%E7%8F%A0/"/>
      <url>/2019/06/08/JS%E9%81%97%E7%8F%A0/</url>
      
        <content type="html"><![CDATA[<p>对于Javascript 的学习从未停止过，奈何其水深无法想象。JS基础回顾，作为前端部分开篇内容再好不过了。 其中包括了 聊雪峰、阮一峰、方应航等大神博文，还有j《avascript 高级程序设计》 一书的内容。 </p><p>夯实基础，开卷有益。</p><h3 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h3><p>script 标签又六个属性。不要用延迟脚本。</p><p>阻断式语言：解释器求值完毕之前，网页不会加载。<br>解释器预处理，再执行。</p><p>手机端：js内部文件可以起到性能优化。</p><p>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><p>ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure><blockquote><p>注： 模板字符串中回车换行也算字符长度。</p></blockquote><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>三种方法 ToString， 其中 <code>null</code> 与 <code>undefined</code> 进行 ToString 汇报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">''</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>).toString()</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><h4 id="string-相关操作方法"><a href="#string-相关操作方法" class="headerlink" title="string 相关操作方法"></a>string 相关操作方法</h4><ol><li><p><code>trim()</code> 去掉调用字符串的前后空格。</p></li><li><p><code>substring()</code>返回指定索引区间的子串：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello, world&apos;</span><br><span class="line">s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;</span><br><span class="line">s.substring(7); // 从索引7开始到结束，返回&apos;world&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>concat()</code> 拼接两个字符串并返回新的字符串。同 Array。</li></ol><p>4.<code>slice()</code>  裁切，同 Array 。</p><ol start="5"><li><code>repalce()</code> 替换字符串中一个字符。</li></ol><h3 id="Boolean-布尔"><a href="#Boolean-布尔" class="headerlink" title="Boolean 布尔"></a>Boolean 布尔</h3><p>每次看到 boolean 内心都不有的为布尔惋惜。俗话说：『老婆取得好，能够活到老啦』</p><h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>两种方式 ToBoolean:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">'2'</span>)</span><br><span class="line">!!<span class="string">"2"</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>五个 Falsy 值 ：<code>0，NaN，null, undefined, &#39;&#39;</code></p><h3 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number 数字"></a>Number 数字</h3><h4 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h4><p>五种方法进行 ToNumber 操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"1"</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>,<span class="number">10</span>) <span class="comment">// 第二个参数表示10进制</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'1.2'</span>)</span><br><span class="line"><span class="string">"1"</span> - <span class="number">0</span></span><br><span class="line">+ <span class="string">"1"</span> <span class="comment">// 取正</span></span><br></pre></td></tr></table></figure></p><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><h4 id="ToObject"><a href="#ToObject" class="headerlink" title="ToObject"></a>ToObject</h4><p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用<code>&#39;&#39;</code>括起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xiaohong = &#123;</span><br><span class="line">    name: &apos;小红&apos;,</span><br><span class="line">    &apos;middle-school&apos;: &apos;No.1 Middle School&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[&apos;middle-school&apos;]; // &apos;No.1 Middle School&apos;</span><br><span class="line">xiaohong[&apos;name&apos;]; // &apos;小红&apos;</span><br><span class="line">xiaohong.name; // &apos;小红&apos;</span><br></pre></td></tr></table></figure><p>也可以用<code>xiaohong[&#39;name&#39;]</code>来访问<code>xiaohong</code>的<code>name</code>属性，不过<code>xiaohong.name</code>的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过<code>object.prop</code>的形式访问一个属性了。</p><p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p><p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming = &#123;</span><br><span class="line">    name: &apos;小明&apos;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(&apos;name&apos;); // true</span><br><span class="line">xiaoming.hasOwnProperty(&apos;toString&apos;); // false</span><br></pre></td></tr></table></figure><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Jack&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;Beijing&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;Jack&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;Beijing&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    if (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">    console.log(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;</span><br><span class="line">    console.log(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>请注意</em>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p><h3 id="set-map……"><a href="#set-map……" class="headerlink" title="set map…….."></a>set map……..</h3><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p><p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。<br>注意区别 for in。 for in 不完善，仅限于对象输出。<br>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.forEach(function (element, index, array) &#123;</span><br><span class="line">    // element: 指向当前元素的值</span><br><span class="line">    // index: 指向当前索引</span><br><span class="line">    // array: 指向Array对象本身</span><br><span class="line">    console.log(element + &apos;, index = &apos; + index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.forEach(function (element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p><code>arguments</code>最常用于判断传入参数的个数。你可能会看到这样的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// foo(a[, b], c)</span><br><span class="line">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span><br><span class="line">function foo(a, b, c) &#123;</span><br><span class="line">    if (arguments.length === 2) &#123;</span><br><span class="line">        // 实际拿到的参数是a和b，c为undefined</span><br><span class="line">        c = b; // 把b赋给c</span><br><span class="line">        b = null; // b变为默认值</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6标准引入了rest参数，用于接收未定义的多余参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo(a, b, ...rest) &#123;</span><br><span class="line">    console.log(&apos;a = &apos; + a);</span><br><span class="line">    console.log(&apos;b = &apos; + b);</span><br><span class="line">    console.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3, 4, 5);</span><br><span class="line">// 结果:</span><br><span class="line">// a = 1</span><br><span class="line">// b = 2</span><br><span class="line">// Array [ 3, 4, 5 ]</span><br><span class="line"></span><br><span class="line">foo(1);</span><br><span class="line">// 结果:</span><br><span class="line">// a = 1</span><br><span class="line">// b = undefined</span><br><span class="line">// Array []</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>自定义全局作用域：<br>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 唯一的全局变量MYAPP:</span><br><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 其他变量:</span><br><span class="line">MYAPP.name = &apos;myapp&apos;;</span><br><span class="line">MYAPP.version = 1.0;</span><br><span class="line"></span><br><span class="line">// 其他函数:</span><br><span class="line">MYAPP.foo = function () &#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把自己的代码全部放入唯一的名字空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。</p><p>许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let  的作用：<br>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    for (var i=0; i&lt;100; i++) &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">    i += 100; // 仍然可以引用变量i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (let i=0; i&lt;100; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    // SyntaxError:</span><br><span class="line">    i += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 解构赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></p><p>从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    gender: &apos;male&apos;,</span><br><span class="line">    passport: &apos;G-12345678&apos;,</span><br><span class="line">    school: &apos;No.4 middle school&apos;,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: &apos;Beijing&apos;,</span><br><span class="line">        street: &apos;No.1 Road&apos;,</span><br><span class="line">        zipcode: &apos;100001&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var &#123;name, address: &#123;city, zip&#125;&#125; = person;</span><br><span class="line">name; // &apos;小明&apos;</span><br><span class="line">city; // &apos;Beijing&apos;</span><br><span class="line">zip; // undefined, 因为属性名是zipcode而不是zip</span><br><span class="line">// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:</span><br><span class="line">address; // Uncaught ReferenceError: address is not defined</span><br></pre></td></tr></table></figure><p>使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为<code>undefined</code>，这和引用一个不存在的属性获得<code>undefined</code>是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    gender: &apos;male&apos;,</span><br><span class="line">    passport: &apos;G-12345678&apos;,</span><br><span class="line">    school: &apos;No.4 middle school&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 把passport属性赋值给变量id:</span><br><span class="line">let &#123;name, passport:id,single=true&#125; = person;</span><br><span class="line">name; // &apos;小明&apos;</span><br><span class="line">single; // true</span><br><span class="line">id; // &apos;G-12345678&apos;</span><br><span class="line">// 注意: passport不是变量，而是为了让变量id获得passport属性:</span><br><span class="line">passport; // Uncaught ReferenceError: passport is not defined</span><br></pre></td></tr></table></figure><p>这是因为JavaScript引擎把<code>{</code>开头的语句当作了块处理，于是<code>=</code>不再合法。解决方法是用小括号括起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;x, y&#125; = &#123; name: &apos;小明&apos;, x: 100, y: 200&#125;);</span><br></pre></td></tr></table></figure><p>快速获取当前页面的域名和路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123;hostname:domain, pathname:path&#125; = location;  // 重命名爲domain</span><br></pre></td></tr></table></figure><p>如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个<code>Date</code>对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123;</span><br><span class="line">    return new Date(year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hour + &apos;:&apos; + minute + &apos;:&apos; + second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的方便之处在于传入的对象只需要<code>year</code>、<code>month</code>和<code>day</code>这三个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildDate(&#123; year: 2017, month: 1, day: 1 &#125;);</span><br><span class="line">// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure><p>也可以传入<code>hour</code>、<code>minute</code>和<code>second</code>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildDate(&#123; year: 2017, month: 1, day: 1, hour: 20, minute: 15 &#125;);</span><br><span class="line">// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>用一个<code>that</code>变量首先捕获<code>this</code>：</p><p>用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    birth: 1990,</span><br><span class="line">    age: function () &#123;</span><br><span class="line">        var that = this; // 在方法内部一开始就捕获this</span><br><span class="line">        function getAgeFromBirth() &#123;</span><br><span class="line">            var y = new Date().getFullYear();</span><br><span class="line">            return y - that.birth; // 用that而不是this</span><br><span class="line">        &#125;</span><br><span class="line">        return getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); // 25</span><br></pre></td></tr></table></figure></p><h1 id="arr-map-arr-reduce"><a href="#arr-map-arr-reduce" class="headerlink" title="arr.map() arr.reduce()"></a>arr.map() arr.reduce()</h1><p><code>map()</code>、<code>reduce</code>、<code>filter()</code>、<code>sort()</code>、every()、find()、findIndex()、forEach()、</p><p>、</p><h1 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h1><p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><h1 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h1><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</p></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</p></li><li><p>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</p></li><li><p>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</p></li><li><p><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</p></li><li><p>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</p></li><li><p>判断<code>null</code>请使用<code>myVar === null</code>；</p></li><li><p>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</p></li><li><p>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</p></li></ul><p><code>number</code>对象调用<code>toString()</code>报SyntaxError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.toString(); // SyntaxError</span><br></pre></td></tr></table></figure><p>遇到这种情况，要特殊处理一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123..toString(); // &apos;123&apos;, 注意是两个点！</span><br><span class="line">(123).toString(); // &apos;123&apos;</span><br></pre></td></tr></table></figure><p>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。</p><h1 id="regExp"><a href="#regExp" class="headerlink" title="regExp"></a>regExp</h1><p>无法识别连续的空格，用正则表达式试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a b   c&apos;.split(/\s+/); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><h4 id="jason"><a href="#jason" class="headerlink" title="jason"></a>jason</h4><p>统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code><br>对象序列化成JSON格式的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var xiaoming = &#123;</span><br><span class="line">    name: &apos;小明&apos;,</span><br><span class="line">    age: 14,</span><br><span class="line">    gender: true,</span><br><span class="line">    height: 1.65,</span><br><span class="line">    grade: null,</span><br><span class="line">    &apos;middle-school&apos;: &apos;\&quot;W3C\&quot; Middle School&apos;,</span><br><span class="line">    skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">var s = JSON.stringify(xiaoming);</span><br><span class="line">console.log(s);</span><br></pre></td></tr></table></figure><p>要输出得好看一些，可以加上参数，按缩进输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(xiaoming, null, &apos;  &apos;);</span><br></pre></td></tr></table></figure><p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入<code>Array</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;小明&quot;,</span><br><span class="line">  &quot;skills&quot;: [</span><br><span class="line">    &quot;JavaScript&quot;,</span><br><span class="line">    &quot;Java&quot;,</span><br><span class="line">    &quot;Python&quot;,</span><br><span class="line">    &quot;Lisp&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>拿到一个JSON格式的字符串，我们直接用<code>JSON.parse()</code>把它变成一个JavaScript对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&apos;[1,2,3,true]&apos;); // [1, 2, 3, true]</span><br><span class="line">JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;); // Object &#123;name: &apos;小明&apos;, age: 14&#125;</span><br><span class="line">JSON.parse(&apos;true&apos;); // true</span><br><span class="line">JSON.parse(&apos;123.45&apos;); // 123.45</span><br></pre></td></tr></table></figure><p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var obj = JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;, function (key, value) &#123;</span><br><span class="line">    if (key === &apos;name&apos;) &#123;</span><br><span class="line">        return value + &apos;同学&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(JSON.stringify(obj)); // &#123;name: &apos;小明同学&apos;, age: 14&#125;</span><br></pre></td></tr></table></figure><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>js 最重要的任务是找到 DOM 上的 element，然后负责添加 css效果类。</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>集合选择器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'\[data-x\]'</span>)</span><br></pre></td></tr></table></figure></p><p>元素选择器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'a\[href="#'</span>+ id +<span class="string">'"\]'</span>).parentNode</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> front end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql</title>
      <link href="/2019/06/08/sql/"/>
      <url>/2019/06/08/sql/</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，最终要的是数据。 DB 分类的开篇总结一些常用的命令，为以后漫长的数据之旅打下基础。</p><h3 id="mysql-cmd"><a href="#mysql-cmd" class="headerlink" title="mysql cmd"></a>mysql cmd</h3><p>服务器上常用mysql命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">mysql -h 10.0.1.99 -u root -p // -h 指定IP或域名</span><br></pre></td></tr></table></figure><h3 id="sql-statement"><a href="#sql-statement" class="headerlink" title="sql statement"></a>sql statement</h3><p>通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>查询 排序。列有相同的数据，要进一步排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score FROM students ORDER BY score DESC，gender;</span><br></pre></td></tr></table></figure></p><p>分页: <code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure></p><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。<code>COUNT(*)</code>和<code>COUNT(id)</code>实际上是一样的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure></p><p><code>ROUP BY</code>子句指定了按<code>class_id</code>分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure></p><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    s.id sid,</span><br><span class="line">    s.name,</span><br><span class="line">    s.gender,</span><br><span class="line">    s.score,</span><br><span class="line">    c.id cid,</span><br><span class="line">    c.name cname</span><br><span class="line">FROM students s, classes c</span><br><span class="line">WHERE s.gender = &apos;M&apos; AND c.id = 1;</span><br></pre></td></tr></table></figure></p><p>inner join 会丢失两表中null 值得数据，这是可以使用FULL OUTER JOIN<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">ON s.class_id = c.id;</span><br></pre></td></tr></table></figure></p><p>要特别小心的是，<code>UPDATE</code>语句可以没有<code>WHERE</code>条件，整个表的所有记录都会被更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">UPDATE students SET score=60;</span><br><span class="line"></span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2019/05/27/Git/"/>
      <url>/2019/05/27/Git/</url>
      
        <content type="html"><![CDATA[<p>开篇想了很久才决定要写什么，作为一名 Web 开发人员，第一必备的技能应该就是 git 了。没什么好说的，记录git一些常用命令，以备查阅。</p><h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><ol><li><p>cmd<br>最常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git status -sb // 参数 sb 很有用~！</span><br><span class="line">git diff</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>git 的状态<br>git init</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git init  //这是一个空的仓库</span><br><span class="line">Initialized empty Git repository in </span><br><span class="line">$ git status -sb // 此时状态为 未跟踪，此时创建文件后为 红色 M </span><br><span class="line">On branch master</span><br><span class="line">Initial commit</span><br><span class="line">Untracked files:xxxx</span><br></pre></td></tr></table></figure></li></ol><p>git add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改文件后</span><br><span class="line">$ git status -sb // 修改文件在工作区，未提交到 stage。 此时为绿色 M </span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit: </span><br><span class="line"></span><br><span class="line">$ git add ./* </span><br><span class="line">$ git status // 从工作区 add 到 stage 区</span><br><span class="line">xxxx</span><br><span class="line">Changes to be committed:</span><br></pre></td></tr></table></figure></p><p>git commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;xxx&quot;</span><br><span class="line"></span><br><span class="line">// 从 stage 提交到 master</span><br></pre></td></tr></table></figure></p><p>git checkout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout --xx //丢弃xx文件工作区修改。.让这个文件回到最近一次</span><br><span class="line"></span><br><span class="line">git checkout dev //切换分支</span><br></pre></td></tr></table></figure></p><p>分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch; // 查看当前分支</span><br><span class="line">git branch dev; 创建分支</span><br><span class="line">git checkout dev ;切换分支</span><br><span class="line">git checkout -b dev; 创建并且换</span><br><span class="line">git merge dev;   先处在master 然后合并分支dev到master</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev //最好使用这条,禁用Fast forward</span><br></pre></td></tr></table></figure></p><p>log<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></p><p>stash 雪藏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 历史将为编辑好工作区缓存去来</span><br><span class="line">git stash     git stash list     git stash apply    git stash drop     git stash pop</span><br></pre></td></tr></table></figure></p><p>git remote -v<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v //查看远端库</span><br></pre></td></tr></table></figure></p><p>tag // 易于团队版本号查询，目前用不上</p><ol start="3"><li>解决冲突</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git diff // 查看不同</span><br><span class="line">git log  --pretty=oneline</span><br><span class="line">git reset --hard HEAD^   //退回上一个版本    </span><br><span class="line">git reset --hard 1094a //退回固定版本</span><br><span class="line"></span><br><span class="line">git reflog</span><br><span class="line">git checkout --xxx //直接丢弃工作区的修改</span><br><span class="line"></span><br><span class="line">//当你不但改乱了工作区某个文件的内容，还添加到了stage区时(add)，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line"></span><br><span class="line">git branch dev;  git checkout dev ;git checkout -b dev //创建并切换分支</span><br><span class="line">git merge dev;    git merge --no-ff -m &quot;merge with no-ff&quot; dev // 合并分支， 在master分支下，合并dev</span><br><span class="line"></span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">git stash     git stash list     git stash apply    git stash drop     git stash pop</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><ol start="4"><li>github</li></ol><p>生成本地钥匙和锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"email.address"</span></span><br></pre></td></tr></table></figure></p><p>~/.ssh 中 生成 钥匙：id_rsa 与 锁 id_rsa.pub。</p><p>将 锁 id_rsa.pub 上传到github。</p><p>尝试连接github，用本地的 钥匙 去开 github 上的锁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>连接成功后，会将github IP 保存到 known_hosts 中。</p><p>至此， 本地与github建立连接。</p><p>git 本地配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config XXXX  // 看文档吧。一辈子配置不了几次。</span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/26/hello-world/"/>
      <url>/2019/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
